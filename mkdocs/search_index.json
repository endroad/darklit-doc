{
    "docs": [
        {
            "location": "/",
            "text": "Welcome Darklit\n\n\nThis is online developper documentation for Darklit project.",
            "title": "Home"
        },
        {
            "location": "/#welcome-darklit",
            "text": "This is online developper documentation for Darklit project.",
            "title": "Welcome Darklit"
        },
        {
            "location": "/nsref.basics/",
            "text": "Basics\n\n\nDeclarations\n\n\nVariables\n\n\nPlain variables\n\n\nint a\nfloat b\n\n\n\nI / O\n\n\nSome variables can be retrieve or set from the C# code.\n\n\nTo use them you need to add \nin\n, \nout\n, \ninout\n in front of variable declaration\n\n\n    in int a\n    out float b\n    inout bool c\n\n\n\n\n\nTo know more about I/O usage see the script templates or consult your local programmer.\nSome scripts like \ncondition script\n requires special output variable\nto be functionnal\n\n\n\n\nEntity\n\n\nEach entity that you'll be using in your script need to be assigned from the C#\nside using a specific name. To make the link from C# to NuSpeak you need to declare it as follow:\n\n\nentity myEntity\n\n\n\n\n\nTo know more about entity usage see the script templates or consult your local programmer.\n\n\n\n\nReserved\n\n\nSome keyword are reserved by the language and/or the GameData framework to allow quick & easy access\nentities that are common.\n\n\n\n\n\n\n\n\nEntity Name\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nthis\n\n\nThe entity running the script.\n\n\n\n\n\n\nself\n\n\nSame as \nthis\n\n\n\n\n\n\ngame\n\n\nThe global game entity containing some useful generic stuff\n\n\n\n\n\n\n\n\nThe \nentities\n above are always defined and usable in any script.\n\n\nOperators\n\n\nArithmetics\n\n\nDefined for \nint\n and \nfloat\n\n\n// Binary\na + b // Addition\na - b // Substraction\na * b // Multiplication\na / b // Division\na % b // Modulo\n\n// Unary\na++   // Postfix increment\n++a   // Prefix increment\na--   // Postfix decrement\n--a   // Prefix decrement\n\n// Assignment\na += b\na -= b\n\n\n\nRelations\n\n\nDefined for \nint\n and \nfloat\n\n\nbool c = a > b  // Greater\nbool c = a >= b // Greater or equal\nbool c = a < b  // Less\nbool c = a <= b // Less or equal\n\n\n\nEquality\n\n\nDefined for \nbool\n, \nint\n and \nfloat\n\n\nbool c = a is b     // Equal\nbool c = a == b     // Equal (equiv.)\n\nbool c = a is not b // Not Equal\nbool c = a isnot b  // Not Equal (equiv.)\nbool c = a != b     // Not Equal (equiv.)\n\n\n\nLogic\n\n\nDefined for \nbool\n only\n\n\nbool c = a and b // And\nbool c = a && b  // And (equiv.)\n\nbool c = a or b  // Or\nbool c = a || b  // Or (equiv.)\n\nbool c = not a   // Not\nbool c = !a      // Not (equiv.)\n\n\n\nConditions\n\n\nif a is b then\n    // do something here ...\nendif\n\n\nif a is b then\n    // do somthing here\nelse if a is c then\n    // do some other thing here\nelse\n    // do some other other thing here\nend",
            "title": "Basics"
        },
        {
            "location": "/nsref.basics/#basics",
            "text": "",
            "title": "Basics"
        },
        {
            "location": "/nsref.basics/#declarations",
            "text": "",
            "title": "Declarations"
        },
        {
            "location": "/nsref.basics/#variables",
            "text": "Plain variables  int a\nfloat b",
            "title": "Variables"
        },
        {
            "location": "/nsref.basics/#i-o",
            "text": "Some variables can be retrieve or set from the C# code.  To use them you need to add  in ,  out ,  inout  in front of variable declaration      in int a\n    out float b\n    inout bool c   To know more about I/O usage see the script templates or consult your local programmer.\nSome scripts like  condition script  requires special output variable\nto be functionnal",
            "title": "I / O"
        },
        {
            "location": "/nsref.basics/#entity",
            "text": "Each entity that you'll be using in your script need to be assigned from the C#\nside using a specific name. To make the link from C# to NuSpeak you need to declare it as follow:  entity myEntity   To know more about entity usage see the script templates or consult your local programmer.",
            "title": "Entity"
        },
        {
            "location": "/nsref.basics/#reserved",
            "text": "Some keyword are reserved by the language and/or the GameData framework to allow quick & easy access\nentities that are common.     Entity Name  Usage      this  The entity running the script.    self  Same as  this    game  The global game entity containing some useful generic stuff     The  entities  above are always defined and usable in any script.",
            "title": "Reserved"
        },
        {
            "location": "/nsref.basics/#operators",
            "text": "",
            "title": "Operators"
        },
        {
            "location": "/nsref.basics/#arithmetics",
            "text": "Defined for  int  and  float  // Binary\na + b // Addition\na - b // Substraction\na * b // Multiplication\na / b // Division\na % b // Modulo\n\n// Unary\na++   // Postfix increment\n++a   // Prefix increment\na--   // Postfix decrement\n--a   // Prefix decrement\n\n// Assignment\na += b\na -= b",
            "title": "Arithmetics"
        },
        {
            "location": "/nsref.basics/#relations",
            "text": "Defined for  int  and  float  bool c = a > b  // Greater\nbool c = a >= b // Greater or equal\nbool c = a < b  // Less\nbool c = a <= b // Less or equal",
            "title": "Relations"
        },
        {
            "location": "/nsref.basics/#equality",
            "text": "Defined for  bool ,  int  and  float  bool c = a is b     // Equal\nbool c = a == b     // Equal (equiv.)\n\nbool c = a is not b // Not Equal\nbool c = a isnot b  // Not Equal (equiv.)\nbool c = a != b     // Not Equal (equiv.)",
            "title": "Equality"
        },
        {
            "location": "/nsref.basics/#logic",
            "text": "Defined for  bool  only  bool c = a and b // And\nbool c = a && b  // And (equiv.)\n\nbool c = a or b  // Or\nbool c = a || b  // Or (equiv.)\n\nbool c = not a   // Not\nbool c = !a      // Not (equiv.)",
            "title": "Logic"
        },
        {
            "location": "/nsref.basics/#conditions",
            "text": "if a is b then\n    // do something here ...\nendif\n\n\nif a is b then\n    // do somthing here\nelse if a is c then\n    // do some other thing here\nelse\n    // do some other other thing here\nend",
            "title": "Conditions"
        },
        {
            "location": "/nsref.ext/",
            "text": "External Access\n\n\nWorking with NuSpeak often will imply to retrieve or set value from/to C#, send message or event\netc... to affect gameplay.\nHere is how to do it.\n\n\nVariables\n\n\nAccess to variable is done using the operator \n->\n on an entity.\nThen followed by the name of the variable (always of the form \nclass.variableName\n)\n\n\nentity myObj\n\n// Read\nint a = myObj->health.life\n\n// Write\nmyObj->health.life = 42\n\n\n\nStats\n\n\nStatistics are equivalent to \nfloat\n variables with the differences that we can \nadd\n effects to theme\nYou can read and write it the same way you do with plain variables.\nHowever:\n\n\n\n\nReading a \nstat\n returns the value with all effects applied to it\n\n\nWriting a \nstat\n sets the \nbase value\n of the \nstat\n.\n\n\n\n\nYou can then add effect to \nstat\n from NuSpeak:\n\n\nentity myObj\nmyObj->health.regen add \"path/to/json\"\n\n\n\nMessages\n\n\nMessages\n are a form of interprocess communication to be able to send specific message to C# or an other NuSpeak script (see Globals for more details on that).\nMessages are send to an \nentity\n and share a lot of syntax with \nvariables\n and \nstats\n.\n\n\nSend the message \nhealth.kill\n that take no arguments\n\n\nentity myObj    \n[myObj health.kill]\n\n\n\nSend a message \nstamina.burst\n that takes 1 argument and returns whether or not it succeeded\n\n\nentity myObj    \nbool didBurst = [myObj stamina.burst: 5]\n\n\n\nSend a message \nhealth.heal\n that takes 2 arguments:\n\n\nentity myObj\n[myObj health.heal:5 overTime:2.0]\n\n\n\nEvents\n\n\nEvents share a lot with \nmessages\n. They have essentially the same syntax, except that the name of the message is \nevent\n\nand the value of the first argument is a \nstring\n with the event name:\n\n\n[this event:\"myAwesomeEvent\" myArgument:5.0]\n[this event:\"awesomeExplosion\" radius:10.0 duration:1.0]\n\n\n\nEvent's arguments are a convention build between the scripter (you!) and the receiver (either FX, Animation, Sound etc...).\nPassing a 'wrong' argument to an \nevent\n will not trigger an error but you might not get the expected result in the end\ndepending on how the \nevent\n is interpreted by the C# code or by another NuSpeak script.\n\n\nGlobals\n\n\nNuSpeak uses static type checking. Which is a fancy way to say that the \ntype\n (whether it's a \nint\n or \nfloat\n etc...) of an expression (let say \na + 4.0\n) is evaluated when you compile the program.\n\n\nHowever it's possible thanks to \nglobals\n to define \ndynamic\n \nvariables\n, \nstats\n or \nmessages\n per \nentity\n.\nThus the type of these dynamic data is unknown at when you compile the program (compile-time) (it's only known when you run the program on \nentity\n)\n\n\nSo... to be able to have correct types in your programs at compile-time you \nmust\n define the type all the \nglobals\n you'll be using in your NuSpeak script.\n\n\n\n\nIt's called a \nforward declaration\n\n\n\n\nIf I'm using in my script the \nglobal\n variable \nlifetime\n I've defined in a \nJson\n file I \nmust\n defined it like that:\n\n\nglobal float lifetime        // Forward definition of 'lifetime'\nthis->global.lifetime = 0    // Usage of 'lifetime'\n\n\n\nVariables & Stats\n\n\nglobal int victoryPoints\nglobal float lifetime\n\n// Statistic\nglobal stat strength\n\n\n\nMessages\n\n\nglobal (bool)doSomething:(int)\nglobal (void)doOtherThing:(int) withArgument:(float) lotOfArguments:(bool)",
            "title": "External"
        },
        {
            "location": "/nsref.ext/#external-access",
            "text": "Working with NuSpeak often will imply to retrieve or set value from/to C#, send message or event\netc... to affect gameplay.\nHere is how to do it.",
            "title": "External Access"
        },
        {
            "location": "/nsref.ext/#variables",
            "text": "Access to variable is done using the operator  ->  on an entity.\nThen followed by the name of the variable (always of the form  class.variableName )  entity myObj\n\n// Read\nint a = myObj->health.life\n\n// Write\nmyObj->health.life = 42",
            "title": "Variables"
        },
        {
            "location": "/nsref.ext/#stats",
            "text": "Statistics are equivalent to  float  variables with the differences that we can  add  effects to theme\nYou can read and write it the same way you do with plain variables.\nHowever:   Reading a  stat  returns the value with all effects applied to it  Writing a  stat  sets the  base value  of the  stat .   You can then add effect to  stat  from NuSpeak:  entity myObj\nmyObj->health.regen add \"path/to/json\"",
            "title": "Stats"
        },
        {
            "location": "/nsref.ext/#messages",
            "text": "Messages  are a form of interprocess communication to be able to send specific message to C# or an other NuSpeak script (see Globals for more details on that).\nMessages are send to an  entity  and share a lot of syntax with  variables  and  stats .  Send the message  health.kill  that take no arguments  entity myObj    \n[myObj health.kill]  Send a message  stamina.burst  that takes 1 argument and returns whether or not it succeeded  entity myObj    \nbool didBurst = [myObj stamina.burst: 5]  Send a message  health.heal  that takes 2 arguments:  entity myObj\n[myObj health.heal:5 overTime:2.0]",
            "title": "Messages"
        },
        {
            "location": "/nsref.ext/#events",
            "text": "Events share a lot with  messages . They have essentially the same syntax, except that the name of the message is  event \nand the value of the first argument is a  string  with the event name:  [this event:\"myAwesomeEvent\" myArgument:5.0]\n[this event:\"awesomeExplosion\" radius:10.0 duration:1.0]  Event's arguments are a convention build between the scripter (you!) and the receiver (either FX, Animation, Sound etc...).\nPassing a 'wrong' argument to an  event  will not trigger an error but you might not get the expected result in the end\ndepending on how the  event  is interpreted by the C# code or by another NuSpeak script.",
            "title": "Events"
        },
        {
            "location": "/nsref.ext/#globals",
            "text": "NuSpeak uses static type checking. Which is a fancy way to say that the  type  (whether it's a  int  or  float  etc...) of an expression (let say  a + 4.0 ) is evaluated when you compile the program.  However it's possible thanks to  globals  to define  dynamic   variables ,  stats  or  messages  per  entity .\nThus the type of these dynamic data is unknown at when you compile the program (compile-time) (it's only known when you run the program on  entity )  So... to be able to have correct types in your programs at compile-time you  must  define the type all the  globals  you'll be using in your NuSpeak script.   It's called a  forward declaration   If I'm using in my script the  global  variable  lifetime  I've defined in a  Json  file I  must  defined it like that:  global float lifetime        // Forward definition of 'lifetime'\nthis->global.lifetime = 0    // Usage of 'lifetime'",
            "title": "Globals"
        },
        {
            "location": "/nsref.ext/#variables-stats",
            "text": "global int victoryPoints\nglobal float lifetime\n\n// Statistic\nglobal stat strength",
            "title": "Variables &amp; Stats"
        },
        {
            "location": "/nsref.ext/#messages_1",
            "text": "global (bool)doSomething:(int)\nglobal (void)doOtherThing:(int) withArgument:(float) lotOfArguments:(bool)",
            "title": "Messages"
        },
        {
            "location": "/nsref.beh/",
            "text": "Behaviour\n\n\nRoutine loop\n\n\nIt's possible to define a \nloop\n in script that will \nyield\n the program execution.\nWhich means that when reaching the \nend\n of the \nloop\n, execution of the program will stop.\nNext time the program is run it will start again at the begginning of the \nloop\n.\n\n\nLet say we have the following script:\n\n\nint a = 0\nloop:\n    a = a + 1\nend\n\n\n\nWhen you run it the \nfirst\n time the value of \na\n will be:\n\n\na = 1\n\n\n\nWhen you run the same program a \nsecond time\n the value of \na\n will be:\n\n\na = 2\n\n\n\nAnd so on and so forth...\n\n\n\n\nLoop\n are used in behaviour script or scripts that are supposed to run every frame.\nHowever as a scripter you're not responsible of calling a script. It's the discretion\nof the programmer in charge to actually call the script when needed\nSo it's again a convention between programmer and scripter\n\n\n\n\nExit a loop\n\n\nYou can exit the parent loop at anytime using the instruction \n[exit]\n.\n\n\nint a = 0\nloop:\n    a = a + 1\n\n    if a >= 3 then\n        [exit]\n    end\nend\n\na = a * 2\n\n\n\nThe above script will exit the \nloop\n on the third run and then execute the code\n\n\na = a * 2\n\n\n\nThe resulting value of \na\n will be\n\n\na = 6\n\n\n\nYield\n\n\nYou can use the \n[yield]\n instruction to stop program execution and resume it to this point next time the program is run.\nAs a \nloop\n would do but this time you control the flow:\n\n\nint a = 42\n[yield]\na = 12\n\n\n\nWhen you run it the \nfirst\n time the value of \na\n will be:\n\n\na = 42\n\n\n\nWhen you run the same program a \nsecond time\n the value of \na\n will be:\n\n\na = 12\n\n\n\nAnd the second time the program will be terminated.\n\n\nState & Routine\n\n\nstate\n or \nroutine\n are code section where you can jump at at any point in your script using the instruction \nexec\n.\nIt's a convenience that allow scripter to split the code into parts that make sense.\n\n\nstate Fury:\n    this->legs.speed add \"CreatureEffects/FurySpeed\"\n    // Do some other stuff\nend\n\nloop:\n    if this->brain.playerDist < 3 then\n        [exec Fury]\n    end\nend\n\n\n\n\n\nYou can use indifferently keyword \nstate\n or \nroutine\n. They do the same thing",
            "title": "Behaviour"
        },
        {
            "location": "/nsref.beh/#behaviour",
            "text": "",
            "title": "Behaviour"
        },
        {
            "location": "/nsref.beh/#routine-loop",
            "text": "It's possible to define a  loop  in script that will  yield  the program execution.\nWhich means that when reaching the  end  of the  loop , execution of the program will stop.\nNext time the program is run it will start again at the begginning of the  loop .  Let say we have the following script:  int a = 0\nloop:\n    a = a + 1\nend  When you run it the  first  time the value of  a  will be:  a = 1  When you run the same program a  second time  the value of  a  will be:  a = 2  And so on and so forth...   Loop  are used in behaviour script or scripts that are supposed to run every frame.\nHowever as a scripter you're not responsible of calling a script. It's the discretion\nof the programmer in charge to actually call the script when needed\nSo it's again a convention between programmer and scripter",
            "title": "Routine loop"
        },
        {
            "location": "/nsref.beh/#exit-a-loop",
            "text": "You can exit the parent loop at anytime using the instruction  [exit] .  int a = 0\nloop:\n    a = a + 1\n\n    if a >= 3 then\n        [exit]\n    end\nend\n\na = a * 2  The above script will exit the  loop  on the third run and then execute the code  a = a * 2  The resulting value of  a  will be  a = 6",
            "title": "Exit a loop"
        },
        {
            "location": "/nsref.beh/#yield",
            "text": "You can use the  [yield]  instruction to stop program execution and resume it to this point next time the program is run.\nAs a  loop  would do but this time you control the flow:  int a = 42\n[yield]\na = 12  When you run it the  first  time the value of  a  will be:  a = 42  When you run the same program a  second time  the value of  a  will be:  a = 12  And the second time the program will be terminated.",
            "title": "Yield"
        },
        {
            "location": "/nsref.beh/#state-routine",
            "text": "state  or  routine  are code section where you can jump at at any point in your script using the instruction  exec .\nIt's a convenience that allow scripter to split the code into parts that make sense.  state Fury:\n    this->legs.speed add \"CreatureEffects/FurySpeed\"\n    // Do some other stuff\nend\n\nloop:\n    if this->brain.playerDist < 3 then\n        [exec Fury]\n    end\nend   You can use indifferently keyword  state  or  routine . They do the same thing",
            "title": "State &amp; Routine"
        },
        {
            "location": "/stemp.cond/",
            "text": "Condition Template\n\n\nUsed to evaluate a condition.\n\n\n\n\n\n\n\n\nI/O\n\n\nType\n\n\nName\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nout\n\n\nbool\n\n\ncondition\n\n\nEvaluated condition",
            "title": "Condition"
        },
        {
            "location": "/stemp.cond/#condition-template",
            "text": "Used to evaluate a condition.     I/O  Type  Name  Comments      out  bool  condition  Evaluated condition",
            "title": "Condition Template"
        },
        {
            "location": "/stemp.effect/",
            "text": "Effect Template\n\n\nUsed to compute an effect.\n\n\n\n\n\n\n\n\nI/O\n\n\nType\n\n\nName\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nin\n\n\nfloat\n\n\ninput\n\n\nBase value\n\n\n\n\n\n\nout\n\n\nfloat\n\n\noutput\n\n\nValue modified by effect",
            "title": "Effect"
        },
        {
            "location": "/stemp.effect/#effect-template",
            "text": "Used to compute an effect.     I/O  Type  Name  Comments      in  float  input  Base value    out  float  output  Value modified by effect",
            "title": "Effect Template"
        },
        {
            "location": "/stemp.beh/",
            "text": "Behaviour Template\n\n\nBehaviour scripts are executed each frame.\nYou can then write whatever you want.\n\n\nThe usage of \nstate\n and  \nloop\n is espescially recommanded.\n\n\nExample:\n\n\nfloat time = 0\n\nloop:\n    time = time + game->time.dt\n\n    if time >= 3.0 then\n        [this event:\"SomeEffect\"]\n        time = 0\n    end\nend",
            "title": "Behaviour"
        },
        {
            "location": "/stemp.beh/#behaviour-template",
            "text": "Behaviour scripts are executed each frame.\nYou can then write whatever you want.  The usage of  state  and   loop  is espescially recommanded.  Example:  float time = 0\n\nloop:\n    time = time + game->time.dt\n\n    if time >= 3.0 then\n        [this event:\"SomeEffect\"]\n        time = 0\n    end\nend",
            "title": "Behaviour Template"
        },
        {
            "location": "/stemp.spawner/",
            "text": "Spawner Template\n\n\nSpawner is executed every frame while the program \nyield\n (that is inside a loop or after \n[yield]\n instructions).\nIt requires the amount of item to spawn.\n\n\n\n\n\n\n\n\nI/O\n\n\nType\n\n\nName\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nout\n\n\nint\n\n\nburst\n\n\nNumber of object to spawn\n\n\n\n\n\n\n\n\nExample: One every 60s\n\n\nout int burst = 0\nint time = 0\nloop:\n    burst = 0\n    time = time + game->time.dt\n    if time >= 60 then\n        burst = 1\n    end\nend\n\n\n\nExample: One every 60s v2\n\n\nStops after spawning \n10\n\n\nout int burst = 0\nint time = 0\nint count = 0\nloop:\n    burst = 0\n    time = time + game->time.dt\n    if time >= 60 then\n        burst = 1\n        count = count + 1\n    end\n\n    if count >= 10 then\n        [exit]\n    end\nend",
            "title": "Spawner"
        },
        {
            "location": "/stemp.spawner/#spawner-template",
            "text": "Spawner is executed every frame while the program  yield  (that is inside a loop or after  [yield]  instructions).\nIt requires the amount of item to spawn.     I/O  Type  Name  Comments      out  int  burst  Number of object to spawn",
            "title": "Spawner Template"
        },
        {
            "location": "/stemp.spawner/#example-one-every-60s",
            "text": "out int burst = 0\nint time = 0\nloop:\n    burst = 0\n    time = time + game->time.dt\n    if time >= 60 then\n        burst = 1\n    end\nend",
            "title": "Example: One every 60s"
        },
        {
            "location": "/stemp.spawner/#example-one-every-60s-v2",
            "text": "Stops after spawning  10  out int burst = 0\nint time = 0\nint count = 0\nloop:\n    burst = 0\n    time = time + game->time.dt\n    if time >= 60 then\n        burst = 1\n        count = count + 1\n    end\n\n    if count >= 10 then\n        [exit]\n    end\nend",
            "title": "Example: One every 60s v2"
        },
        {
            "location": "/commands.game/",
            "text": "Developpers Commands\n\n\nfly\n\n\nSwitch flycam mode on and off\n\n\nfly\n\n\n\narchetype\n\n\nLoad an archetype \nmyArchetype\n on the player. This a path to JSon.\n\n\narchetype myArchetype\n\n\n\nrespawn\n\n\nRespawn the player to last respawn point\n\n\nrespawn\n\n\n\nzombie\n\n\nEnable or disable the zombie mode\n\n\nzombie [on|off]",
            "title": "Game"
        },
        {
            "location": "/commands.game/#developpers-commands",
            "text": "",
            "title": "Developpers Commands"
        },
        {
            "location": "/commands.game/#fly",
            "text": "Switch flycam mode on and off  fly",
            "title": "fly"
        },
        {
            "location": "/commands.game/#archetype",
            "text": "Load an archetype  myArchetype  on the player. This a path to JSon.  archetype myArchetype",
            "title": "archetype"
        },
        {
            "location": "/commands.game/#respawn",
            "text": "Respawn the player to last respawn point  respawn",
            "title": "respawn"
        },
        {
            "location": "/commands.game/#zombie",
            "text": "Enable or disable the zombie mode  zombie [on|off]",
            "title": "zombie"
        },
        {
            "location": "/commands.dev/",
            "text": "Developpers Commands\n\n\ndatabase\n\n\ndatabase [flush | reload] [--all]\n\n\n\nflush\n Flush from the database\n\n\nreload\n Reload into the database\n\n\n--all\n Apply operation to all known data tree\n\n\nExamples\n\n\ndatabase flush --all  // flush all\ndatabase reload --all // reload all\n\n\n\nnu\n\n\nnu [dump [--irtree|--ircode|--parsetree|--symbols] [--all] [programName]]\n\n\n\ndump\n Dump program info\n\n\n--irtree\n Dump IR Tree (AST)\n\n\n--ircode\n Dump IR Code\n\n\n--parsetree\n Dump parse tree\n\n\n--symbols\n Dump debug symbols\n\n\n--all\n Apply dump to all programs\n\n\nExamples\n\n\nnu dump --ircode --all               // dump ir code of all programs\nnu dump --irtree --parsetree --all   // dump IR tree and parse tree of all programs\nnu dump --irtree \"MyFile/MyProgram\"  // dump IR tree of MyProgram located in MyFile.ns",
            "title": "Dev"
        },
        {
            "location": "/commands.dev/#developpers-commands",
            "text": "",
            "title": "Developpers Commands"
        },
        {
            "location": "/commands.dev/#database",
            "text": "database [flush | reload] [--all]  flush  Flush from the database  reload  Reload into the database  --all  Apply operation to all known data tree",
            "title": "database"
        },
        {
            "location": "/commands.dev/#examples",
            "text": "database flush --all  // flush all\ndatabase reload --all // reload all",
            "title": "Examples"
        },
        {
            "location": "/commands.dev/#nu",
            "text": "nu [dump [--irtree|--ircode|--parsetree|--symbols] [--all] [programName]]  dump  Dump program info  --irtree  Dump IR Tree (AST)  --ircode  Dump IR Code  --parsetree  Dump parse tree  --symbols  Dump debug symbols  --all  Apply dump to all programs",
            "title": "nu"
        },
        {
            "location": "/commands.dev/#examples_1",
            "text": "nu dump --ircode --all               // dump ir code of all programs\nnu dump --irtree --parsetree --all   // dump IR tree and parse tree of all programs\nnu dump --irtree \"MyFile/MyProgram\"  // dump IR tree of MyProgram located in MyFile.ns",
            "title": "Examples"
        },
        {
            "location": "/gameData/gameObject/",
            "text": "gameObject\n\n\nVariables\n\n\ngameObject.isActive\n\n\nbool gameObject.isActive\n\n\nReturns if the object is active.\n\n\ngameObject.isActiveInHierarchy\n\n\nbool gameObject.isActiveInHierarchy\n\n\nIs the GameObject active in the scene?\n\n\nStats\n\n\nMessage",
            "title": "gameObject"
        },
        {
            "location": "/gameData/gameObject/#gameobject",
            "text": "",
            "title": "gameObject"
        },
        {
            "location": "/gameData/gameObject/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/gameObject/#gameobjectisactive",
            "text": "bool gameObject.isActive  Returns if the object is active.",
            "title": "gameObject.isActive"
        },
        {
            "location": "/gameData/gameObject/#gameobjectisactiveinhierarchy",
            "text": "bool gameObject.isActiveInHierarchy  Is the GameObject active in the scene?",
            "title": "gameObject.isActiveInHierarchy"
        },
        {
            "location": "/gameData/gameObject/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/gameObject/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/net/",
            "text": "net\n\n\nVariables\n\n\nnet.hasAutority\n\n\nbool net.hasAutority\n\n\nThis returns true if this object is the authoritative version of the object in the distributed network application.\n\n\nnet.isServer\n\n\nbool net.isServer\n\n\nReturns true if this object is active on an active server.\n\n\nnet.isClient\n\n\nbool net.isClient\n\n\nReturns true if running as a client and this object was spawned by a server.\n\n\nnet.isLocalPlayer\n\n\nbool net.isLocalPlayer\n\n\nReturns\n\n\nStats\n\n\nMessage",
            "title": "net"
        },
        {
            "location": "/gameData/net/#net",
            "text": "",
            "title": "net"
        },
        {
            "location": "/gameData/net/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/net/#nethasautority",
            "text": "bool net.hasAutority  This returns true if this object is the authoritative version of the object in the distributed network application.",
            "title": "net.hasAutority"
        },
        {
            "location": "/gameData/net/#netisserver",
            "text": "bool net.isServer  Returns true if this object is active on an active server.",
            "title": "net.isServer"
        },
        {
            "location": "/gameData/net/#netisclient",
            "text": "bool net.isClient  Returns true if running as a client and this object was spawned by a server.",
            "title": "net.isClient"
        },
        {
            "location": "/gameData/net/#netislocalplayer",
            "text": "bool net.isLocalPlayer  Returns",
            "title": "net.isLocalPlayer"
        },
        {
            "location": "/gameData/net/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/net/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/time/",
            "text": "time\n\n\nVariables\n\n\ntime.dt\n\n\nfloat time.dt\n\n\nTime interval since last frame.\n\n\nStats\n\n\nMessage",
            "title": "time"
        },
        {
            "location": "/gameData/time/#time",
            "text": "",
            "title": "time"
        },
        {
            "location": "/gameData/time/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/time/#timedt",
            "text": "float time.dt  Time interval since last frame.",
            "title": "time.dt"
        },
        {
            "location": "/gameData/time/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/time/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/transform/",
            "text": "transform\n\n\nVariables\n\n\nStats\n\n\nMessage",
            "title": "transform"
        },
        {
            "location": "/gameData/transform/#transform",
            "text": "",
            "title": "transform"
        },
        {
            "location": "/gameData/transform/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/transform/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/transform/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/__vmtest/",
            "text": "__vmtest\n\n\nVariables\n\n\n__vmtest.myInt\n\n\nint __vmtest.myInt\n\n\nUndocumented\n\n\n__vmtest.myFloat\n\n\nint __vmtest.myFloat\n\n\nUndocumented\n\n\nStats\n\n\nMessage\n\n\n__vmtest.mySubstractionMessage\n\n\n(float)__vmtest.mySubstractionMessage:(int)a b:(float)b\n\nHello Workd\n\n\nArguments\n\n\nint a\n: Some usage\n\n\nfloat b\n: Some other\n\n\nReturns\n\n\nSome last",
            "title": "__vmtest"
        },
        {
            "location": "/gameData/__vmtest/#__vmtest",
            "text": "",
            "title": "__vmtest"
        },
        {
            "location": "/gameData/__vmtest/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/__vmtest/#__vmtestmyint",
            "text": "int __vmtest.myInt  Undocumented",
            "title": "__vmtest.myInt"
        },
        {
            "location": "/gameData/__vmtest/#__vmtestmyfloat",
            "text": "int __vmtest.myFloat  Undocumented",
            "title": "__vmtest.myFloat"
        },
        {
            "location": "/gameData/__vmtest/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/__vmtest/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/__vmtest/#__vmtestmysubstractionmessage",
            "text": "(float)__vmtest.mySubstractionMessage:(int)a b:(float)b \nHello Workd",
            "title": "__vmtest.mySubstractionMessage"
        },
        {
            "location": "/gameData/__vmtest/#arguments",
            "text": "int a : Some usage  float b : Some other",
            "title": "Arguments"
        },
        {
            "location": "/gameData/__vmtest/#returns",
            "text": "Some last",
            "title": "Returns"
        },
        {
            "location": "/gameData/spawner/",
            "text": "spawner\n\n\nVariables\n\n\nspawner.local\n\n\nbool spawner.local\n\n\nWhether or not the spawn is local to\n            the current entity.\n\n\nspawner.descriptor\n\n\nstring spawner.descriptor\n\n\nDescriptor to spawn. \n            If starts with \ndata:\n the rest will be interpreted as a json path\n            if starts with \nprefab:\n it's a name of a registered prefab\n            by default it's a prefab.\n\n\nspawner.script\n\n\nstring spawner.script\n\n\nScript that runs continuously to spawn over time.\n\n\nStats\n\n\nMessage\n\n\nspawner.burst\n\n\n(void)spawner.burst:(int)count\n\nSpawn several item.\n\n\nArguments\n\n\nint count\n: Amount to spawn.\n\n\nReturns\n\n\nN/A\n\n\nspawner.spawn\n\n\n(void)spawner.spawn\n\nUndocumented\n\n\nspawner.reset\n\n\n(void)spawner.reset\n\nUndocumented",
            "title": "spawner"
        },
        {
            "location": "/gameData/spawner/#spawner",
            "text": "",
            "title": "spawner"
        },
        {
            "location": "/gameData/spawner/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/spawner/#spawnerlocal",
            "text": "bool spawner.local  Whether or not the spawn is local to\n            the current entity.",
            "title": "spawner.local"
        },
        {
            "location": "/gameData/spawner/#spawnerdescriptor",
            "text": "string spawner.descriptor  Descriptor to spawn. \n            If starts with  data:  the rest will be interpreted as a json path\n            if starts with  prefab:  it's a name of a registered prefab\n            by default it's a prefab.",
            "title": "spawner.descriptor"
        },
        {
            "location": "/gameData/spawner/#spawnerscript",
            "text": "string spawner.script  Script that runs continuously to spawn over time.",
            "title": "spawner.script"
        },
        {
            "location": "/gameData/spawner/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/spawner/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/spawner/#spawnerburst",
            "text": "(void)spawner.burst:(int)count \nSpawn several item.",
            "title": "spawner.burst"
        },
        {
            "location": "/gameData/spawner/#arguments",
            "text": "int count : Amount to spawn.",
            "title": "Arguments"
        },
        {
            "location": "/gameData/spawner/#returns",
            "text": "N/A",
            "title": "Returns"
        },
        {
            "location": "/gameData/spawner/#spawnerspawn",
            "text": "(void)spawner.spawn \nUndocumented",
            "title": "spawner.spawn"
        },
        {
            "location": "/gameData/spawner/#spawnerreset",
            "text": "(void)spawner.reset \nUndocumented",
            "title": "spawner.reset"
        },
        {
            "location": "/gameData/Character/",
            "text": "Character\n\n\nVariables\n\n\nCharacter.Crouch_LateralSpeed\n\n\nfloat Character.Crouch_LateralSpeed\n\n\nUndocumented\n\n\nStats\n\n\nCharacter.Motion\n\n\nfloat Character.Motion\n\n\nUndocumented\n\n\nCharacter.Damage\n\n\nfloat Character.Damage\n\n\nUndocumented\n\n\nMessage",
            "title": "Character"
        },
        {
            "location": "/gameData/Character/#character",
            "text": "",
            "title": "Character"
        },
        {
            "location": "/gameData/Character/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/Character/#charactercrouch_lateralspeed",
            "text": "float Character.Crouch_LateralSpeed  Undocumented",
            "title": "Character.Crouch_LateralSpeed"
        },
        {
            "location": "/gameData/Character/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/Character/#charactermotion",
            "text": "float Character.Motion  Undocumented",
            "title": "Character.Motion"
        },
        {
            "location": "/gameData/Character/#characterdamage",
            "text": "float Character.Damage  Undocumented",
            "title": "Character.Damage"
        },
        {
            "location": "/gameData/Character/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/brain/",
            "text": "brain\n\n\nVariables\n\n\nbrain.playerDist\n\n\nfloat brain.playerDist\n\n\nDistance to closest player.\n\n\nStats\n\n\nMessage",
            "title": "brain"
        },
        {
            "location": "/gameData/brain/#brain",
            "text": "",
            "title": "brain"
        },
        {
            "location": "/gameData/brain/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/brain/#brainplayerdist",
            "text": "float brain.playerDist  Distance to closest player.",
            "title": "brain.playerDist"
        },
        {
            "location": "/gameData/brain/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/brain/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/legs/",
            "text": "legs\n\n\nVariables\n\n\nlegs.isStopped\n\n\nbool legs.isStopped\n\n\nWhether the creature is stopped or not\n\n\nStats\n\n\nlegs.speed\n\n\nfloat legs.speed\n\n\nMoving speed.\n\n\nMessage\n\n\nlegs.MoveForward\n\n\n(void)legs.MoveForward\n\nUndocumented\n\n\nlegs.Turn\n\n\n(void)legs.Turn:(float)angle\n\nTurns the facing direction of @angle degrees\n\n\nArguments\n\n\nfloat angle\n: \n\n\nReturns\n\n\nN/A\n\n\nlegs.Stop\n\n\n(void)legs.Stop\n\nUndocumented\n\n\nlegs.Resume\n\n\n(void)legs.Resume\n\nUndocumented",
            "title": "legs"
        },
        {
            "location": "/gameData/legs/#legs",
            "text": "",
            "title": "legs"
        },
        {
            "location": "/gameData/legs/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/legs/#legsisstopped",
            "text": "bool legs.isStopped  Whether the creature is stopped or not",
            "title": "legs.isStopped"
        },
        {
            "location": "/gameData/legs/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/legs/#legsspeed",
            "text": "float legs.speed  Moving speed.",
            "title": "legs.speed"
        },
        {
            "location": "/gameData/legs/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/legs/#legsmoveforward",
            "text": "(void)legs.MoveForward \nUndocumented",
            "title": "legs.MoveForward"
        },
        {
            "location": "/gameData/legs/#legsturn",
            "text": "(void)legs.Turn:(float)angle \nTurns the facing direction of @angle degrees",
            "title": "legs.Turn"
        },
        {
            "location": "/gameData/legs/#arguments",
            "text": "float angle :",
            "title": "Arguments"
        },
        {
            "location": "/gameData/legs/#returns",
            "text": "N/A",
            "title": "Returns"
        },
        {
            "location": "/gameData/legs/#legsstop",
            "text": "(void)legs.Stop \nUndocumented",
            "title": "legs.Stop"
        },
        {
            "location": "/gameData/legs/#legsresume",
            "text": "(void)legs.Resume \nUndocumented",
            "title": "legs.Resume"
        },
        {
            "location": "/gameData/Health/",
            "text": "Health\n\n\nVariables\n\n\nHealth.Current\n\n\nint Health.Current\n\n\nUndocumented\n\n\nStats\n\n\nHealth.Regen\n\n\nfloat Health.Regen\n\n\nUndocumented\n\n\nHealth.Capacity\n\n\nfloat Health.Capacity\n\n\nUndocumented\n\n\nMessage\n\n\nHealth.Damage\n\n\n(void)Health.Damage:(int)amount\n\nApply damages: remove the amount.\n\n\nArguments\n\n\nint amount\n: Amount of damages to apply.\n\n\nReturns\n\n\nN/A\n\n\nHealth.Burst\n\n\n(bool)Health.Burst:(float)amount\n\nTry to remove a value.\n\n\nArguments\n\n\nfloat amount\n: Amount to remove\n\n\nReturns\n\n\nTrue if succeeded to remove (that is there's enough quantity to remove).\n\n\nHealth.Recover\n\n\n(void)Health.Recover:(int)amount\n\nUndocumented",
            "title": "Health"
        },
        {
            "location": "/gameData/Health/#health",
            "text": "",
            "title": "Health"
        },
        {
            "location": "/gameData/Health/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/Health/#healthcurrent",
            "text": "int Health.Current  Undocumented",
            "title": "Health.Current"
        },
        {
            "location": "/gameData/Health/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/Health/#healthregen",
            "text": "float Health.Regen  Undocumented",
            "title": "Health.Regen"
        },
        {
            "location": "/gameData/Health/#healthcapacity",
            "text": "float Health.Capacity  Undocumented",
            "title": "Health.Capacity"
        },
        {
            "location": "/gameData/Health/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/Health/#healthdamage",
            "text": "(void)Health.Damage:(int)amount \nApply damages: remove the amount.",
            "title": "Health.Damage"
        },
        {
            "location": "/gameData/Health/#arguments",
            "text": "int amount : Amount of damages to apply.",
            "title": "Arguments"
        },
        {
            "location": "/gameData/Health/#returns",
            "text": "N/A",
            "title": "Returns"
        },
        {
            "location": "/gameData/Health/#healthburst",
            "text": "(bool)Health.Burst:(float)amount \nTry to remove a value.",
            "title": "Health.Burst"
        },
        {
            "location": "/gameData/Health/#arguments_1",
            "text": "float amount : Amount to remove",
            "title": "Arguments"
        },
        {
            "location": "/gameData/Health/#returns_1",
            "text": "True if succeeded to remove (that is there's enough quantity to remove).",
            "title": "Returns"
        },
        {
            "location": "/gameData/Health/#healthrecover",
            "text": "(void)Health.Recover:(int)amount \nUndocumented",
            "title": "Health.Recover"
        },
        {
            "location": "/gameData/Oxygen/",
            "text": "Oxygen\n\n\nVariables\n\n\nStats\n\n\nMessage",
            "title": "Oxygen"
        },
        {
            "location": "/gameData/Oxygen/#oxygen",
            "text": "",
            "title": "Oxygen"
        },
        {
            "location": "/gameData/Oxygen/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/Oxygen/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/Oxygen/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/Stamina/",
            "text": "Stamina\n\n\nVariables\n\n\nStamina.Current\n\n\nint Stamina.Current\n\n\nUndocumented\n\n\nStats\n\n\nStamina.Regen\n\n\nfloat Stamina.Regen\n\n\nUndocumented\n\n\nStamina.Capacity\n\n\nfloat Stamina.Capacity\n\n\nUndocumented\n\n\nMessage\n\n\nStamina.Damage\n\n\n(void)Stamina.Damage:(int)amount\n\nApply damages: remove the amount.\n\n\nArguments\n\n\nint amount\n: Amount of damages to apply.\n\n\nReturns\n\n\nN/A\n\n\nStamina.Burst\n\n\n(bool)Stamina.Burst:(float)amount\n\nTry to remove a value.\n\n\nArguments\n\n\nfloat amount\n: Amount to remove\n\n\nReturns\n\n\nTrue if succeeded to remove (that is there's enough quantity to remove).\n\n\nStamina.Recover\n\n\n(void)Stamina.Recover:(int)amount\n\nUndocumented",
            "title": "Stamina"
        },
        {
            "location": "/gameData/Stamina/#stamina",
            "text": "",
            "title": "Stamina"
        },
        {
            "location": "/gameData/Stamina/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/Stamina/#staminacurrent",
            "text": "int Stamina.Current  Undocumented",
            "title": "Stamina.Current"
        },
        {
            "location": "/gameData/Stamina/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/Stamina/#staminaregen",
            "text": "float Stamina.Regen  Undocumented",
            "title": "Stamina.Regen"
        },
        {
            "location": "/gameData/Stamina/#staminacapacity",
            "text": "float Stamina.Capacity  Undocumented",
            "title": "Stamina.Capacity"
        },
        {
            "location": "/gameData/Stamina/#message",
            "text": "",
            "title": "Message"
        },
        {
            "location": "/gameData/Stamina/#staminadamage",
            "text": "(void)Stamina.Damage:(int)amount \nApply damages: remove the amount.",
            "title": "Stamina.Damage"
        },
        {
            "location": "/gameData/Stamina/#arguments",
            "text": "int amount : Amount of damages to apply.",
            "title": "Arguments"
        },
        {
            "location": "/gameData/Stamina/#returns",
            "text": "N/A",
            "title": "Returns"
        },
        {
            "location": "/gameData/Stamina/#staminaburst",
            "text": "(bool)Stamina.Burst:(float)amount \nTry to remove a value.",
            "title": "Stamina.Burst"
        },
        {
            "location": "/gameData/Stamina/#arguments_1",
            "text": "float amount : Amount to remove",
            "title": "Arguments"
        },
        {
            "location": "/gameData/Stamina/#returns_1",
            "text": "True if succeeded to remove (that is there's enough quantity to remove).",
            "title": "Returns"
        },
        {
            "location": "/gameData/Stamina/#staminarecover",
            "text": "(void)Stamina.Recover:(int)amount \nUndocumented",
            "title": "Stamina.Recover"
        },
        {
            "location": "/gameData/World/",
            "text": "World\n\n\nVariables\n\n\nWorld.HasGround\n\n\nbool World.HasGround\n\n\nWhether has a ground under.\n\n\nWorld.HasWallLeft\n\n\nbool World.HasWallLeft\n\n\nCheck if has a wall on left.\n\n\nWorld.HasWallRight\n\n\nbool World.HasWallRight\n\n\nHas wall on the right.\n\n\nWorld.ceil\n\n\nbool World.ceil\n\n\nHas ceiling.\n\n\nStats\n\n\nMessage",
            "title": "World"
        },
        {
            "location": "/gameData/World/#world",
            "text": "",
            "title": "World"
        },
        {
            "location": "/gameData/World/#variables",
            "text": "",
            "title": "Variables"
        },
        {
            "location": "/gameData/World/#worldhasground",
            "text": "bool World.HasGround  Whether has a ground under.",
            "title": "World.HasGround"
        },
        {
            "location": "/gameData/World/#worldhaswallleft",
            "text": "bool World.HasWallLeft  Check if has a wall on left.",
            "title": "World.HasWallLeft"
        },
        {
            "location": "/gameData/World/#worldhaswallright",
            "text": "bool World.HasWallRight  Has wall on the right.",
            "title": "World.HasWallRight"
        },
        {
            "location": "/gameData/World/#worldceil",
            "text": "bool World.ceil  Has ceiling.",
            "title": "World.ceil"
        },
        {
            "location": "/gameData/World/#stats",
            "text": "",
            "title": "Stats"
        },
        {
            "location": "/gameData/World/#message",
            "text": "",
            "title": "Message"
        }
    ]
}